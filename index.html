<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var scenes;
        var sceneToRender = null;
        var currentSceneMeshes =[]; 
        var meshNodeData = [];
        var meshParent;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        /**
         * WebXR ar demo using hit-test, anchors, and plane detection.
         * 
         * Every press on the screen will add a figure in the requested position (if the ring is displayed). Those meshes will be kept in place by the AR system you are using.
         * 
         * Working (at the moment) on android devices and the latest chrome.
         * 
         * Created by Raanan Weber (@RaananW)
         */
        
        var createScene = async function () {
        
            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);
            
            var tapCount =0;
        
            // This creates and positions a free camera (non-mesh)
            var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 1, -5), scene);
        
            // This targets the camera to scene origin
            camera.setTarget(BABYLON.Vector3.Zero());
        
            // This attaches the camera to the canvas
            camera.attachControl(canvas, true);
        
            // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        
            // Default intensity is 1. Let's dim the light a small amount
            light.intensity = 0.7;
        
            var dirLight = new BABYLON.DirectionalLight('light', new BABYLON.Vector3(0, -1, -0.5), scene);
            dirLight.position = new BABYLON.Vector3(0, 5, -5);
        
            var shadowGenerator = new BABYLON.ShadowGenerator(1024, dirLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
        
            readJson();

           // const model = await BABYLON.SceneLoader.ImportMeshAsync("", "", "dummy3.babylon", scene);
        
            var xr = await scene.createDefaultXRExperienceAsync({
                uiOptions: {
                    sessionMode: "immersive-ar",
                    referenceSpaceType: "local-floor"
                },
                optionalFeatures: true
            });
        
            const fm = xr.baseExperience.featuresManager;
        
            const xrTest = fm.enableFeature(BABYLON.WebXRHitTest.Name, "latest");
            const xrPlanes = fm.enableFeature(BABYLON.WebXRPlaneDetector.Name, "latest");
            const anchors = fm.enableFeature(BABYLON.WebXRAnchorSystem.Name, 'latest');
        
            const xrBackgroundRemover = fm.enableFeature(BABYLON.WebXRBackgroundRemover.Name);
        
          //  let b = model.meshes[0];//BABYLON.CylinderBuilder.CreateCylinder('cylinder', { diameterBottom: 0.2, diameterTop: 0.4, height: 0.5 });
            let b = BABYLON.CylinderBuilder.CreateCylinder('cylinder', { diameterBottom: 0.2, diameterTop: 0.4, height: 0.5 });
            b.rotationQuaternion = new BABYLON.Quaternion();
            // b.isVisible = false;
            shadowGenerator.addShadowCaster(b, true);
        
            const marker = BABYLON.MeshBuilder.CreateTorus('marker', { diameter: 0.15, thickness: 0.05 });
            marker.isVisible = false;
            marker.rotationQuaternion = new BABYLON.Quaternion();
        
          
            let hitTest;
        
            b.isVisible = false;
        
            xrTest.onHitTestResultObservable.add((results) => {
                if (results.length) {
                    if(tapCount==0)
                    {
                        marker.isVisible = true;
                    }
                    hitTest = results[0];
                    /*
                    for(let i=0;i<meshNodeData.length;i++)
                    {
                      hitTest.transformationMatrix.decompose(undefined, meshNodeData[i].rotationQuaternion, meshNodeData[i].position);
                    }
                    */
                  //  hitTest.transformationMatrix.decompose(undefined, meshNodeData[0].rotationQuaternion, meshNodeData[0].position);
                    hitTest.transformationMatrix.decompose(undefined, meshParent.rotationQuaternion, meshParent.position);
                    hitTest.transformationMatrix.decompose(undefined, marker.rotationQuaternion, marker.position);
                } else {
                    marker.isVisible = false;
                    hitTest = undefined;
                }
            });
            const mat1 = new BABYLON.StandardMaterial('1', scene);
            mat1.diffuseColor = BABYLON.Color3.Red();
            const mat2 = new BABYLON.StandardMaterial('1', scene);
            mat2.diffuseColor = BABYLON.Color3.Blue();
        
            if (anchors) {
                console.log('anchors attached');
                anchors.onAnchorAddedObservable.add(anchor => {
                    console.log('attaching', meshNodeData.length);
                  //  b.isVisible = true;
                    /*
                    for(let i=0;i<meshNodeData.length;i++)
                    {
                        meshNodeData[i].isVisible=true;
                      console.log("aaa "+meshNodeData[i]);
                      anchor.attachedNode = meshNodeData[i];
                    }
                    */
                 //   anchor.attachedNode = b;//b.clone("mensch");
                    
                    meshNodeData[0].isVisible=true;
                 //   anchor.attachedNode = meshNodeData[0];
                    anchor.attachedNode = meshParent;
                    
                    const children = meshNodeData[0].getChildren();
                    for (let i = 0; i < children.length; i++) {
                        const child = children[i];
                        // Do something with each child node
                        child.isVisible=true;
                    }
                    
                    shadowGenerator.addShadowCaster(anchor.attachedNode, true);
                   
                    //disable from scene 2
                    for(let i=1;i<meshNodeData.length;i++)
                    {
                      meshNodeData[i].isVisible=false;
                    }
                   // b.isVisible = false;
                })
        
                anchors.onAnchorRemovedObservable.add(anchor => {
                    console.log('disposing', anchor);
                    if (anchor) {
                        anchor.attachedNode.isVisible = false;
                        anchor.attachedNode.dispose();
                    }
                });
            }
        
            scene.onPointerDown = (evt, pickInfo) => {
                if (hitTest && anchors && xr.baseExperience.state === BABYLON.WebXRState.IN_XR) {
                    if(tapCount==0)
                    {
                        anchors.addAnchorPointUsingHitTestResultAsync(hitTest);
                        tapCount++;
                        marker.isVisible=false;
                    }
                }
                console.log("picked mesh "+pickInfo.pickedMesh.name);
                
                this.scenes.forEach(element => {
                element.meshObjects.forEach(element => {
                        if(pickInfo.pickedMesh.name.includes(element.meshType))
                       {
                           console.log("go to scene "+element.actions);
                           loadSceneNew(parseInt(element.actions));
                       }
                    });
                });
            }
        
            const planes = [];
        
            xrPlanes.onPlaneAddedObservable.add(plane => {
                plane.polygonDefinition.push(plane.polygonDefinition[0]);
                var polygon_triangulation = new BABYLON.PolygonMeshBuilder("name", plane.polygonDefinition.map((p) => new BABYLON.Vector2(p.x, p.z)), scene);
                var polygon = polygon_triangulation.build(false, 0.01);
                plane.mesh = polygon; //BABYLON.TubeBuilder.CreateTube("tube", { path: plane.polygonDefinition, radius: 0.02, sideOrientation: BABYLON.Mesh.FRONTSIDE, updatable: true }, scene);
                //}
                planes[plane.id] = (plane.mesh);
                const mat = new BABYLON.StandardMaterial("mat", scene);
                mat.alpha = 0.5;
                mat.diffuseColor = BABYLON.Color3.Random();
                polygon.createNormals();
                // polygon.receiveShadows = true;
                plane.mesh.material = mat;
        
                plane.mesh.rotationQuaternion = new BABYLON.Quaternion();
                plane.transformationMatrix.decompose(plane.mesh.scaling, plane.mesh.rotationQuaternion, plane.mesh.position);
            });
        
            xrPlanes.onPlaneUpdatedObservable.add(plane => {
                let mat;
                if (plane.mesh) {
                    mat = plane.mesh.material;
                    plane.mesh.dispose(false, false);
                }
                const some = plane.polygonDefinition.some(p => !p);
                if (some) {
                    return;
                }
                plane.polygonDefinition.push(plane.polygonDefinition[0]);
                var polygon_triangulation = new BABYLON.PolygonMeshBuilder("name", plane.polygonDefinition.map((p) => new BABYLON.Vector2(p.x, p.z)), scene);
                var polygon = polygon_triangulation.build(false, 0.01);
                polygon.createNormals();
                plane.mesh = polygon;// BABYLON.TubeBuilder.CreateTube("tube", { path: plane.polygonDefinition, radius: 0.02, sideOrientation: BABYLON.Mesh.FRONTSIDE, updatable: true }, scene);
                //}
                planes[plane.id] = (plane.mesh);
                plane.mesh.material = mat;
                plane.mesh.rotationQuaternion = new BABYLON.Quaternion();
                plane.transformationMatrix.decompose(plane.mesh.scaling, plane.mesh.rotationQuaternion, plane.mesh.position);
                plane.mesh.receiveShadows = true;
            })
        
            xrPlanes.onPlaneRemovedObservable.add(plane => {
                if (plane && planes[plane.id]) {
                    planes[plane.id].dispose()
                }
            })
        
            xr.baseExperience.sessionManager.onXRSessionInit.add(() => {
                planes.forEach(plane => plane.dispose());
                while (planes.pop()) { };
            });
        
            
        
            return scene;
        
        };
                window.initFunction = async function() {
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};



        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; }); 
        });


        function readJson(){
    var data = '[{"id":0,"name":"newScene","meshObjects":[{"id":"0","name":"newGLTF","sceneId":1,"meshType":"cube","isLock":false,"position":{"x":2.033468008041382,"y":0,"z":0},"rotation":{"x":0,"y":0,"z":0},"scale":{"x":1,"y":-1,"z":1},"actions":0},{"id":"1","name":"newGLTF","sceneId":1,"meshType":"capsule","isLock":false,"position":{"x":-1.2087178230285645,"y":0,"z":0},"rotation":{"x":0,"y":0,"z":0},"scale":{"x":2.3395471572875977,"y":-1.9307323694229126,"z":2.346611738204956},"actions":2}]},{"id":1,"name":"newScene","meshObjects":[{"id":"6","name":"torus","sceneId":1,"meshType":"gltf","isLock":false,"position":{"x":0,"y":0,"z":0},"rotation":{"x":0,"y":0,"z":0},"scale":{"x":1,"y":1,"z":1},"actions":0}]}]';
    
    
    scenes = JSON.parse(data);

    console.log("a mesh  "+JSON.stringify(scenes));

        this.scenes.forEach(element => {
      element.meshObjects.forEach(element => {
        this.currentGLTFPosition = new BABYLON.Vector3(element.position?.x,element.position?.y,element.position?.z);
        if(element.meshType!="gltf")
        {
        element.mesh= this.addSceneMesh(element.meshType, this.currentGLTFPosition);
        console.log("z pos"+element.position?.z);
        element.mesh.position = new BABYLON.Vector3(element.position?.x*0.4,element.position?.y*0.4,element.position?.z*0.4);
        element.mesh.rotation = new BABYLON.Vector3(element.rotation?.x,element.rotation?.y,element.rotation?.z);
        element.mesh.scaling = new BABYLON.Vector3(element.scale?.x*0.4,element.scale?.y*0.4,element.scale?.z*0.4);
        element.mesh.setEnabled(false);
        console.log("");
        }else
        {
          this.addSceneMesh(element.meshType, this.currentGLTFPosition);
        }
      });
    });
    this.generatePreview();
}
        
      function loadgltf(){
              var dummy ;
             var sceneTwo = new BABYLON.Scene(engine);
          console.log("gltf to be added");
         
         
              const torusKnott = BABYLON.MeshBuilder.CreateTorusKnot('torusKnott', {}, this.scene);
              console.log("add");
          const gltfObject = BABYLON.SceneLoader.ImportMesh(
            "",
            "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Box/glTF/", "Box.gltf",
            sceneTwo,
            (meshes) => {
          //   meshes[0].position = gltfPos;
          //   dummy = this.getParentMesh(meshes[0]);
             
             console.log("gltf object loaded : ");
            }
          );

          /*
           // @ts-ignore
        gltfObject.onMeshLoadedObservable.addOnce(meshData => {
          
       //   this.gltfObjects.push(this.getParentMesh(meshData));
          console.log("waaat "+meshData);
      //    meshData.setEnabled(false);
     //     this.addGLTFMesh();
        });
         */

        }



      function addSceneMesh( meshType, position) {
        console.log("mesh type : "+meshType);
      switch (meshType) {
        case ShapeType.Sphere:
          const sphere = BABYLON.MeshBuilder.CreateSphere('sphere', {}, this.scene);
          return sphere;
          break;
        case ShapeType.Cube:
          const cube = BABYLON.MeshBuilder.CreateBox('cube', {}, this.scene);
          console.log('cube Added: ', cube)
          return cube;
          break;
        case ShapeType.Cylinder:
          const cylinder = BABYLON.MeshBuilder.CreateCylinder('cylinder', {}, this.scene);
          return cylinder
          break;
        case ShapeType.Cone:
          const cone = BABYLON.MeshBuilder.CreateCylinder('cone', {}, this.scene);
          console.log('cone Added: ', cone)
          return cone;
          break;
        case ShapeType.Capsule:
          const capsule = BABYLON.MeshBuilder.CreateCapsule('capsule', {}, this.scene);
          console.log('capsule Added: ', capsule)
          return capsule;
          break;
        case ShapeType.PolyheDron:
          const polyhedron = BABYLON.MeshBuilder.CreatePolyhedron('polyhedron', {}, this.scene);
          console.log('polyhedron Added: ', polyhedron)
          return polyhedron;
          break;
        case ShapeType.GoldBerg:
          const goldberg = BABYLON.MeshBuilder.CreateGoldberg('goldberg', {}, this.scene);
          console.log('goldberg Added: ', goldberg)
          return goldberg;
          break;
        case ShapeType.IcoSphere:
          const icosphere = BABYLON.MeshBuilder.CreateIcoSphere('icosphere', {}, this.scene);
          console.log('icosphere Added: ', icosphere)
          return icosphere;
          break;
        case ShapeType.Torus:
          const torus = BABYLON.MeshBuilder.CreateTorus('torus', {}, this.scene);
          console.log('torus Added: ', torus)
          return torus;
          break;
        case ShapeType.TorusKnot:
          const torusKnot = BABYLON.MeshBuilder.CreateTorusKnot('torusKnot', {}, this.scene);
          console.log('torusKnot Added: ', torusKnot)
          return torusKnot;
          break;
        case ShapeType.GLTF:
            this.loadgltf();
          break;
        case ShapeType.Image:
          var planeOpts = {
            height: 1,
            width: 1,
            sideOrientation: BABYLON.Mesh.DOUBLESIDE
          };
          var Image = BABYLON.MeshBuilder.CreatePlane("plane", planeOpts, this.scene);
          var pos = (new BABYLON.Vector3(0, 0, 0.1))
          Image.position = pos;
          // texture and material
          var url = "https://upload.wikimedia.org/wikipedia/en/8/86/Einstein_tongue.jpg";
          var mat = new BABYLON.StandardMaterial("mat1", this.scene);
          //mat.backFaceCulling = false;
          var texture = new BABYLON.Texture(url, this.scene);
          mat.diffuseTexture = texture;
    
          Image.material = mat;
          return Image;
          break;
        case ShapeType.Video:
          var planeOpts = {
            height: 1,
            width: 1,
            sideOrientation: BABYLON.Mesh.DOUBLESIDE
          };
          var Video = BABYLON.MeshBuilder.CreatePlane("plane", planeOpts, this.scene);
          var vidPos = (new BABYLON.Vector3(0, 0, 0.1))
          Video.position = vidPos;
          var ANote0VideoMat = new BABYLON.StandardMaterial("m", this.scene);
          var ANote0VideoVidTex = new BABYLON.VideoTexture("babylon", "assets/babylon.mp4", this.scene);
          ANote0VideoMat.diffuseTexture = ANote0VideoVidTex;
          ANote0VideoMat.roughness = 1;
          ANote0VideoMat.emissiveColor = BABYLON.Color3.White();
          Video.material = ANote0VideoMat;
          // ANote0VideoVidTex.video.play();
              /*
          this.scene.onPointerObservable.add(function (evt) {
            if (evt.pickInfo?.pickedMesh === Video) {
              //console.log("picked");
              if (ANote0VideoVidTex.video.paused)
                ANote0VideoVidTex.video.play();
              else
                ANote0VideoVidTex.video.pause();
              console.log(ANote0VideoVidTex.video.paused ? "paused" : "playing");
            }
          }, PointerEventTypes.POINTERPICK);
          */
          return Video;
          break;
      }
      console.log('Meshes List: ', this.currentSceneMeshes);
      console.log('Get Object pos: ');
       
      
      var dumm = new BABYLON.Mesh("dummy", this.scene);
      return dumm;
    }



      function generatePreview() {
    console.log("Generate Preview code");
 //   this.loadScene(1);
    fillNodeMeshData();
    
  }


function fillNodeMeshData() {
    meshParent = BABYLON.MeshBuilder.CreateCylinder('cylinder', { diameterBottom: 0, diameterTop: 0, height: 0.5 });
  for (let i = 0; i < scenes.length; i++) {
    let a = BABYLON.MeshBuilder.CreateCylinder('cylinder', { diameterBottom: 0, diameterTop: 0, height: 0.5 });
    meshNodeData[i] = a;

    for (let meshObj of scenes[i].meshObjects) {
      console.log("mesh name" + meshObj.name);
      if (meshObj.mesh) {
          meshObj.mesh.setEnabled(true);
        console.log("mesh exists "+meshObj.mesh.name);
        let meshCopy = meshObj.mesh.clone(meshObj.mesh.name + "_copy");
     //   meshCopy.position = new BABYLON.Vector3(0, 0, 0);
        meshCopy.parent = meshNodeData[i];
        meshObj.mesh.setEnabled(false);
        meshCopy.isVisible=false;
      }
    }
      meshNodeData[i].parent = meshParent;
      meshNodeData[i].isVisible=false;
  }
  console.log("node mesh data filled!");
}
        
        function loadSceneNew(index){
            if(index==0)
            {
                return;
            }
            
            console.log("load scene index : "+index);
           for(let i=0;i<meshNodeData.length;i++)
           {
                if(i==index-1)
                {
                    console.log("aaaa "+i);
                    
                    const children = meshNodeData[i].getChildren();
                    for (let j = 0; j < children.length; j++) 
                    {
                        const child = children[j];
                        // Do something with each child node
                        child.isVisible=true;
                    }
                    meshNodeData[i].isVisible =true;
                   
                }
                else
                {
                    console.log("nnn "+i);
                    meshNodeData[i].isVisible = false;
                    const children = meshNodeData[i].getChildren();
                    for (let j = 0; j < children.length; j++) 
                    {
                        const child = children[j];
                        // Do something with each child node
                        child.isVisible=false;
                    }
                    meshNodeData[i].isVisible = false;
                }
            }
        }


  function loadScene(index) {
    console.log("index : "+index);
    
  //  this.enableSceneMesh(false);

    if(this.scenes[index-1]!=null)
    {
      this.currentSceneMeshes = this.scenes[index-1].meshObjects;
      this.enableSceneMesh(true);
    }else
    {
      this.currentSceneMeshes=[];
    }

    this.sceneIndex=index-1;
  }

  function enableSceneMesh(value) 
  {
    let meshObj;
    if(this.currentSceneMeshes)
    {
      for (meshObj of this.currentSceneMeshes) {
        console.log("mesh name"+meshObj.name+value);
        if(meshObj.mesh)
        {
          console.log("mesh exist");
          meshObj.mesh.setEnabled(value);
        }else
        {
          console.log("mesh doesnt exists");
        }
        
      }
    }
  }










        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });

        const ShapeType ={
  Sphere: 'sphere',
  Cube : 'cube',
  Cylinder : 'cylinder',
  Cone : 'cone',
  Capsule : 'capsule',
  PolyheDron : 'polyhedron',
  GoldBerg : 'goldberg',
  IcoSphere : 'icosphere',
  Torus : 'torus',
  TorusKnot : 'torusKnot',
  GLTF : 'gltf',
  Video : 'Video',
  Image : 'Image'
}
    </script>
</body>
</html>
